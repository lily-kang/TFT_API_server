
1) API 엔드포인트 설계(동기·원샷 파이프라인)

POST /pipeline/run-batch
	•	입력: 여러 지문을 items 배열로 전달 (각 항목에 식별자 client_id 포함)
	•	처리: 서버 내부에서 각 항목을 run_pipeline 로직으로 순차/병렬 처리
	•	출력: 항목별 결과 배열 (성공/실패 혼재 가능)

요청 예시:
```json
{
  "items": [
    {
      "client_id": "row_12",              // 시트에서 온 식별자(행 번호/ job_id 등)
      "original_text": "원문 A",
      "title": "Story A",
      "generated_passage": "검수대상 A",
      "include_syntax": true,
      "master": {
        "AVG_SENTENCE_LENGTH": 12.3,
        "All_Embedded_Clauses_Ratio": 0.18,
        "CEFR_NVJD_A1A2_lemma_ratio": 0.46
      },
      "tolerance_abs": { "AVG_SENTENCE_LENGTH": 1.97 },
      "tolerance_ratio": {
        "All_Embedded_Clauses_Ratio": 0.202,
        "CEFR_NVJD_A1A2_lemma_ratio": 0.104
      },
      "syntax_candidates": 3,
      "lexical_candidates": 3
    },
    {
      "client_id": "row_13",
      "original_text": "원문 B",
      "title": "Story B",
      "generated_passage": "검수대상 B",
      "include_syntax": true,
      "master": { "AVG_SENTENCE_LENGTH": 11.1, "All_Embedded_Clauses_Ratio": 0.22, "CEFR_NVJD_A1A2_lemma_ratio": 0.40 }
    }
  ]
}
```
응답 예시
```json
{
  "results": [
    {
      "client_id": "row_12",
      "status": "final",
      "syntax_pass": "PASS",
      "lexical_pass": "PASS",
      "detailed_result": "[syntax] ...\n[lexical] ...",
      "final_text": "최종 텍스트 A",
      "attempts": { "syntax": 1, "lexical": 1 },
      "trace": [ /* 항목별 과정 로그 (옵션) */ ]
    },
    {
      "client_id": "row_13",
      "status": "lexical_fail",
      "syntax_pass": "PASS",
      "lexical_pass": "FAIL",
      "detailed_result": "[lexical] ...",
      "final_text": null,
      "attempts": { "syntax": 0, "lexical": 0 }
    }
  ]
}
```

2) flow 

지문 들어옴

구문 수정 클래스, 어휘수정 클래스가 있어야함. 클래스 내부 파이프라인은  동일함. 
구문 수정 과 어휘 수정은 각각의 긴 프롬프트를 가지고 있어서 llm 으로 하여금 수정하게 해. 대신 수정 시 llm temperature를 각각 다르게 해서 (예. 0.2, 0.3, 0.4) 로 수정 버전을 생성하게 한다. 생성된 버전 3가지 중  하나를 Llm 이 최선의 지문을 고르는 과정이 있어. 참고해.

flow는
처음 지문들어옴 -> 1차 분석기 검수 : 3개 지표 통과 여부를 확인하여 분기를 나누어 진행. 3개 지표는 AVG_SENTENCE_LENGTH, All_Embedded_Clauses_Ratio, CEFR_NVJD_A1A2_lemma_ratio 임

앞의 2개 가 구문 지표, A1A2 lemma ratio 가 어휘 지표임
모두 통과 시:  이 지문은 더 수정할 필요가 없음 final 지문임.
구문 만 통과하고 어휘 통과 x -> 어휘 수정 llm 호출 필요
구문 통과 x -> 무조건 구문 수정 llm 호출 필요.

구문 수정 llm 완료 되면 후보 지문 3개에 대해서 분석기 다시 돌려야함. 분석 결과 구문 지표 모두 통과하면 3개 후보 중 최적지문 선택을 llm 이 진행함.

최적지문 1개가 나왔는데, 직전에 분석기 결과를 봤을때 어휘 통과 안했을때에는, 어휘 수정 모듈로 감. 

직전 분석기 결과 구문 어휘 모두 통과했으면 final.

후보 지문 중 어느것도 구문 지표를 통과하지 못하면 discard

어휘수정 모듈 에서도 같은 순서로 판단한다. 
통과 못하면 discard.


3) 파이프라인 의사코드(단일 호출) 예시

```python
def run_pipeline(payload):
    text = payload.get("generated_passage") or payload["original_text"]
    master = payload["master"]
    tol_abs = payload.get("tolerance_abs", {"AVG_SENTENCE_LENGTH": 1.97})
    tol_ratio = payload.get("tolerance_ratio", {
        "All_Embedded_Clauses_Ratio": 0.202,
        "CEFR_NVJD_A1A2_lemma_ratio": 0.104,
    })
    trace = []
    attempts = {"syntax": 0, "lexical": 0}

    # 1) 분석
    raw = analyzer.analyze(text, include_syntax=True)
    ext = metrics.extract(raw)
    res = judge.evaluate(ext, master, tol_abs, tol_ratio)
    trace.append({"step":"analyze","metrics":ext,"syntax_pass":res["syntax_pass"],"lexical_pass":res["lexical_pass"]})

    if res["syntax_pass"] == "PASS" and res["lexical_pass"] == "PASS":
        return final_out(text, res, attempts, trace)

    # 2) 구문 실패 → 구문 수정
    if res["syntax_pass"] != "PASS":
        cand, chosen = llm.fix_syntax(text, n=payload.get("syntax_candidates",3))
        attempts["syntax"] += 1
        text = chosen
        trace.append({"step":"fix_syntax","candidates":cand,"selected":chosen})

        # 재분석
        raw = analyzer.analyze(text, include_syntax=True)
        ext = metrics.extract(raw)
        res = judge.evaluate(ext, master, tol_abs, tol_ratio)
        trace.append({"step":"reanalyze","metrics":ext,"syntax_pass":res["syntax_pass"],"lexical_pass":res["lexical_pass"]})

        # 규칙: 구문 또 FAIL → discard
        if res["syntax_pass"] != "PASS":
            return discard_out("syntax reanalyze failed", res, attempts, trace)

        # 구문 PASS인데 어휘 FAIL이면 계속 진행
        if res["lexical_pass"] == "PASS":
            return final_out(text, res, attempts, trace)

    # 3) 어휘 실패 → 어휘 수정
    if res["lexical_pass"] != "PASS":
        cand, chosen = llm.fix_lexical(text, n=payload.get("lexical_candidates",3))
        attempts["lexical"] += 1
        text = chosen
        trace.append({"step":"fix_lexical","candidates":cand,"selected":chosen})

        # 재분석
        raw = analyzer.analyze(text, include_syntax=True)
        ext = metrics.extract(raw)
        res = judge.evaluate(ext, master, tol_abs, tol_ratio)
        trace.append({"step":"reanalyze","metrics":ext,"syntax_pass":res["syntax_pass"],"lexical_pass":res["lexical_pass"]})

        if res["syntax_pass"] == "PASS" and res["lexical_pass"] == "PASS":
            return final_out(text, res, attempts, trace)
        else:
            return discard_out("lexical reanalyze failed", res, attempts, trace)
```
